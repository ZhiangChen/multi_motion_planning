#include <ros/ros.h> 
#include <std_msgs/Float64.h> 
#include <nav_msgs/OccupancyGrid.h>
#include <geometry_msgs/PointStamped.h>
#include <iostream>
using namespace std;

nav_msgs::OccupancyGrid g_map;
bool got_map = false;
int g_width;
int g_height;
double g_rsl;
double g_x;
double g_y;
void myCallback(const nav_msgs::OccupancyGrid& map) 
{ 

  ROS_INFO("received the map."); 
  g_map = map;
  g_width = g_map.info.width;
  g_height = g_map.info.height;
  ROS_INFO("Width x Height: (%d x %d)", g_width, g_height);
  g_x = g_map.info.origin.position.x;
  g_y = g_map.info.origin.position.y;
  ROS_INFO("Origin: (%f, %f)", g_x, g_y);
  g_rsl = g_map.info.resolution;
  ROS_INFO("Resoluntion: %f",g_rsl);
  int n = g_map.data.size();
  ROS_INFO("Points: %d", n);
  geometry_msgs::PointStamped pt;
  got_map = true;

} 

int main(int argc, char **argv) 
{ 
  ros::init(argc,argv,"map_checker"); //name this node 
  // when this compiled code is run, ROS will recognize it as a node called "minimal_subscriber" 
  ros::NodeHandle n; 
  ros::Subscriber my_subscriber_object= n.subscribe("/map",1,myCallback); 
  ros::Publisher map_pub = n.advertise<nav_msgs::OccupancyGrid>("/my_map", 1);

  double x,y;
  int i_x,i_y;
  while(ros::ok())
  {
    ros::spinOnce(); 
    if(got_map)
    {
      cout<<"Input the point's position: ";
      cin>>x>>y;
      i_x = (x-g_x)/g_rsl;
      i_y = (y-g_y)/g_rsl;
      cout<<"Occupancy: "<<int(g_map.data[g_width * (i_y)+ i_x])<<endl; 
    }
  }
  

  return 0; 
} 
